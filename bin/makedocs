#!/usr/bin/env ruby

## WARNING: This file is VERY ugly & quite the hackjob.

require 'bundler'
Bundler.require :default

require 'yaml'
require 'erb'

class Template
  def render(temp)
    ERB.new(temp).result(binding)
  rescue SyntaxError => e
    throw StandardError.new(e)
  end
end

class Index < Template
  def self.path
    'src/docs/_index.html.erb'
  end

  def generate(path)
    template = File.read(self.class.path)
    out = render(template) { source }
    out = HtmlBeautifier.beautify(out)

    File.open(path, 'w') { |f| f.write out }
  end
end

IDENTIFIER_REGEX = /[_A-Za-z]?[_A-Za-z0-9]*/

class Mod
  attr_accessor :id, :name, :description, :commands, :path

  def initialize(config_file)
    config = YAML.load(File.open(config_file).read)

    @path = File.dirname(config_file)
    @id = File.basename(@path)
    @name = config['name']
    @description = config['description']
    @commands = config['commands'].map { |text| Command.new(self, text) }.sort_by(&:name)
  end

  def output_path
    "_release/help/commands/#{name.underscore}"
  end

  def help_dir
    File.join(path, 'docs')
  end

  def examples_dir
    File.join(help_dir, 'examples')
  end
end

class Command
  class Template < ::Template
    def root_path
      '_release/help/commands'
    end

    def layout_path
      'src/docs/commands/_layout.html.erb'
    end

    def relative_to_root
      relative_to(root_path)
    end

    def relative_to(path)
      output_parts = output_path.split('/')
      path_parts = path.split('/')
      while output_parts.first == path_parts.first && !output_parts.empty? && !path_parts.empty?
        output_parts.shift
        path_parts.shift
      end
      path = [Array.new(output_parts.size - 1) { '..' }, path_parts].flatten.join('/')
      path.present? ? path : '.'
      #throw [output_parts, path_parts, output_path, path]
    end
  end

  class Help < Template
    attr_accessor :modules, :command

    def self.path
      'src/docs/commands/_command.html.erb'
    end

    def initialize(modules, command)
      @modules = modules
      @command = command
    end

    def output_path
      command.output_path
    end

    def generate(source)
      template = File.read(layout_path)
      out = render(template) { source }
      out = HtmlBeautifier.beautify(out)

      FileUtils.mkdir_p(File.dirname(output_path))
      File.open(output_path, 'w') { |f| f.write out }
    end
  end

  attr_accessor :mod, :name, :return_type, :params, :symbol

  class Parameter
    REGEX = /^([_A-Za-z]?[_A-Za-z0-9]*)(%|#|\$)(?:=(-?[0-9]+))?/

    attr_accessor :identifier, :type, :default

    def initialize(code)
      _, @identifier, @type, @default = code.match(REGEX).to_a
      throw 'invalid param' unless @identifier.present? && @type.present?
    end

    def to_s
      [identifier, type, default && "=#{default}"].compact.join('')
    end
  end

  def initialize(mod, code)
    @mod = mod
    match = code.match(/^(#{IDENTIFIER_REGEX})(%|#|\$)?\(\s*(.*)\s*\)(:"(#{IDENTIFIER_REGEX})")/)
    _, @name, @return_type, @params, _, @symbol = match.to_a
    @params.strip!
    @params = @params.split(',').map { |s| Parameter.new(s) }
  end

  def output_path
    File.join(mod.output_path, [name, 'html'].join('.'))
  end

  def signature
    rt = return_type != '%' && return_type

    if return_type.blank?
      [name, ' ', params.join(',')].join('')
    else
      [name, return_type, '( ', params ,' )'].join('')
    end
  end

  class View < Nokogiri::HTML::Document
    attr_accessor :command

    def cleanup!(command)
      @command = command

      name_header = xpath('//h1').first

      if name_header
        name_header.content = command.signature
      end
    end

    def has_description?
      xpath('//h2').find { |node| node.text == 'Description' }
    end

    def example_path
      return false if example_link.nil?
      example_path = File.join(command.mod.path, 'docs', example_href)
      example_path && File.exist?(example_path) && example_path
    end

    def example_link
      xpath('//a').find { |node| node.text == 'Example' }
    end

    def example_href
      example_link && example_link['href']
    end

    def example_link=(path)
      if path.present?
        if example_link.nil?
          doc = Nokogiri::XML("<h2><a href=\"#{example_path}\">Example</a></h2>")
          xpath('//body').children.last.after(doc.root)
        end

        example_source = File.open(path).read
        example_link.parent.after("\n<code><pre>\n#{example_source}</pre></code>")
      end
    end

    def parameters_header
      xpath('//h2').find { |node| node.content == 'Parameters' }
    end

    def has_parameters?
      !parameters_header.nil?
    end

    def parameters
      return [] unless has_parameters?
      list = parameters_header.xpath('following-sibling::ul').first
      return [] unless list
      list.xpath('li').map do |item|
        begin
          Parameter.new(item.content)
        rescue
          ident = item.content.match(/^#{IDENTIFIER_REGEX}/)
          Parameter.new("#{ident}%")
        end
      end
    end
  end

  def html_help
    markdown = File.read(help_exists? ? help_path : 'src/docs/commands/not_found.md')

    markdown = Help.new([], self).render(markdown)

    source = GitHub::Markup.render_s(GitHub::Markups::MARKUP_MARKDOWN, markdown)

    doc = View.parse(source)
    doc.cleanup! self
    doc
  end

  def help
    html_doc = html_help
    html_doc.example_link = example_path
    html_doc.xpath('//body').children
  end

  def help_exists?
    help_path
  end

  def help_path
    markdown_path = "#{mod.path}/docs/#{name}.md"
    File.exist?(markdown_path) ? markdown_path : nil
  end

  def example_path
    path = html_help.example_path || "#{mod.path}/docs/examples/#{name}.bb"
    File.exist?(path) ? path : nil
  end

  def example_exists?
    example_path.present?
  end

  def help_or_example_exists?
    help_exists? || example_exists?
  end
end

class CommandIndex < Command::Template
  attr_reader :modules

  def initialize(modules)
    @modules = modules
  end

  # def input_path
  #   'src/docs/commands/_index.html.erb'
  # end

  def input_path
    'src/docs/commands/_index.html.erb'
  end

  def output_path
    '_release/help/commands/index.html'
  end

  def generate
    template = File.read(layout_path)
    out = render(template) { File.open(input_path).read }
    out = HtmlBeautifier.beautify(out)

    File.open(output_path, 'w') { |f| f.write out }
  end
end

class ModIndex < Command::Template
  attr_reader :modules, :mod

  def initialize(modules, mod)
    @modules = modules
    @mod = mod
  end

  def input_path
    'src/docs/commands/_module.html.erb'
  end

  def output_path
    "_release/help/commands/#{mod.id}/index.html"
  end

  def generate
    template = File.read(layout_path)
    out = render(template) { render(File.open(input_path).read) }
    out = HtmlBeautifier.beautify(out)

    File.open(output_path, 'w') { |f| f.write out }
  end
end


def find_modules
  Dir.glob('src/runtime/bb/*/module.yml').map { |path| Mod.new(path) }
end

def run
  puts 'Generating help...'

  modules = find_modules

  modules.each do |mod|
    puts "Found #{mod.name.bold}. #{mod.commands.size} commands."
    mod.commands.each do |command|
      puts "  #{command.help_exists? ? command.name.green : command.name.red}"
      Command::Help.new(modules, command).generate command.help
    end

    ModIndex.new(modules, mod).generate
  end

  Index.new.generate('_release/help/index.html')
  CommandIndex.new(modules).generate

  puts "Writing command #{'index.json'.bold}..."
  index = modules.map do |mod|
    {
      name: mod.name,
      commands: mod.commands.map do |command|
        {
          name: command.name
        }
      end
    }
  end

  File.open('_release/help/commands/index.json', 'w') { |f| f.write JSON.pretty_generate(index) }
end

if ARGV.include?('--lint')
  find_modules.each do |mod|
    puts "Checking #{mod.name.bold}..."

    justsize = mod.commands.map { |command| command.name.size }.max

    mod.commands.each do |command|
      errors, warnings = [], []

      errors << 'missing help' unless command.help_exists?
      warnings << 'missing example' unless command.example_exists?

      html = command.html_help

      errors << 'missing description' unless html.has_description?

      if !command.params.empty?
        if html.parameters.empty?
          warnings << 'missing parameters'
        else
          decl_params = command.params.map(&:identifier)
          html_params = html.parameters.map(&:identifier)

          command.params.each { |p| warnings << "missing \"#{p.identifier}\" in parameters list" unless html_params.include?(p.identifier) }
          html.parameters.each { |p| warnings << "has unknown \"#{p.identifier}\" in parameters list" unless decl_params.include?(p.identifier) }
        end
      elsif html.has_parameters?
        warnings << "shouldn't have parameters"
      end

      html.parameters

      name = "#{command.name}:".ljust(justsize + 1)

      messages = []

      messages << (errors.to_sentence << '.').red unless errors.empty?
      messages << (warnings.to_sentence << '.').yellow unless warnings.empty?

      # messages << 'all good.'.green if errors.empty? && warnings.empty?

      puts "  #{name} #{messages.join(' ')}" unless messages.blank?
    end
  end

  exit 0
end

if ARGV.include?('--import')
  i = ARGV.find_index('--import')
  module_name = ARGV[i + 1]
  if module_name.blank?
    puts "Invalid module name given for import.".red
    exit 1
  end

  mod = find_modules.find { |modul| modul.id == module_name }
  if mod.blank?
    puts "Cannot find module '#{module_name}' for import.".red
    exit 1
  end

  puts "Importing commands for #{mod.name.bold}..."
  mod.commands.each do |command|
    next if command.help_exists? && command.example_exists?

    existing_help    = Dir.glob("_release/help/commands/*_commands/#{command.name}.htm").first
    existing_example = Dir.glob("_release/help/commands/*_examples/#{command.name}.bb").first

    if !command.help_exists? && existing_help.present?
      existing_help = Nokogiri::HTML(File.open(existing_help).read)
      existing_help = existing_help.xpath('//body').children
      existing_help.children.before('<span class="autoimport"></span>')
      new_help = File.join(mod.help_dir, [command.name, 'md'].join('.'))

      File.open(new_help, 'w') { |f| f.write existing_help.to_html }
      # FileUtils.mkdir_p mod.help_dir
      # FileUtils.cp existing_help,
      puts "  Copied help for #{command.name.bold}"
    end

    if !command.example_exists? && existing_example.present?
      FileUtils.mkdir_p mod.examples_dir
      FileUtils.cp existing_example, File.join(mod.examples_dir, File.basename(existing_example))
      puts "  Copied example for #{command.name.bold}"
    end
  end

  exit 0
end

# begin
  run
# rescue StandardError => e
#   puts e
# end

if ARGV.include?('--watch')
  puts 'Watching for changes...'.yellow
  FileWatcher.new(['src/docs', 'src/runtime/**/*.md']).watch do
    begin
      run
    rescue StandardError => e
      puts e
    end
  end
end
